package clientRPC

import (
	"context"
	"log"

	"google.golang.org/grpc/metadata"
)

//
// import (
// 	"context"
// 	"log"
//
// 	"gitlab.lan/Rightnao-site/microservices/company/pkg/internal/company-errors"
// 	"google.golang.org/grpc/codes"
// 	"google.golang.org/grpc/metadata"
// 	"google.golang.org/grpc/status"
// )
//
// func handleError(err error) error {
// 	// gRPC status
// 	if st, ok := status.FromError(err); ok {
// 		switch st.Code() {
// 		case codes.OK:
// 			return nil
// 		case codes.AlreadyExists:
// 			return companyErrors.ErrAlreadyExists
// 		case codes.NotFound:
// 			return companyErrors.ErrNotFound
// 		case codes.InvalidArgument:
// 			return companyErrors.ErrWrongArgument
//
// 			// codes.OutOfRange
// 			// codes.DataLoss
// 			// codes.Aborted
// 			// codes.FailedPrecondition
//
// 		default:
// 			// codes below are generated by gRPC
//
// 			// codes.Canceled
// 			// codes.DeadlineExceeded
// 			// codes.Internal
// 			// codes.PermissionDenied
// 			// codes.ResourceExhausted
// 			// codes.Unavailable
// 			// codes.Unimplemented
// 			// codes.Unknown
// 			// codes.Unauthenticated
// 			return companyErrors.ErrInternalError
// 		}
// 	}
//
// 	// golang error
// 	return err
// }

func passContext(ctx *context.Context) {

	md, b := metadata.FromIncomingContext(*ctx)
	if b {
		*ctx = metadata.NewOutgoingContext(*ctx, md)
	} else {
		log.Println("error while passing context")
	}
}

func retriveToken(ctx context.Context) string {
	md, ok := metadata.FromIncomingContext(ctx)
	if ok {
		arr := md.Get("token")
		if len(arr) > 0 {
			return arr[0]
		}
	}
	return ""
}
